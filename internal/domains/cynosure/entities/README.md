# Entities

> TL;DR: **Entity** — объект доменной модели с устойчивой идентичностью и
> жизненным циклом. **Component** (см. соседний README) = неизменяемый
> value‑object / семантический тип. **Aggregate** (см. план, будет позже) =
> транзакционная оболочка вокруг набора entities + инварианты.

## Общее описание

Entities моделируют предметные "сущности", которые:

1. Имеют **идентичность** (ID остаётся тем же, даже если свойства меняются).
2. Могут **изменяться** со временем (смена состояния, метаданных, привязок и
   т.п.).
3. Хранят *минимум* мутабельного состояния; сложные значения инкапсулируются в
   компоненты (value‑objects).
4. Отвечают за локальные инварианты (не за "широкие" бизнес‑процессы — это зона
   usecase / aggregate).

## Отличие от Компонентов

Компоненты (value-objects) отличаются от энтити по нескольким ключевым принципам. Во-первых, идентичность работает по-разному: компоненты **не имеют** собственной идентичности — два объекта с одинаковыми значениями считаются равными. Энтити же идентифицируются по уникальному ID, и даже при изменении свойств остаются "той же самой" сущностью.

Мутабельность — это второе важное отличие. Компоненты неизменяемы после создания — если нужно "изменить" значение, создаётся новый объект. Энтити допускают контролируемые изменения состояния через специальные методы.

Валидация тоже происходит по-разному. В компонентах валидация происходит только в конструкторе — создали валидный объект и больше не беспокоимся. В энтити проверки выполняются в каждом методе изменения состояния для поддержания инвариантов.

Что касается хранения, то компоненты обычно встраиваются как поля в другие структуры (энтити или агрегаты). Энтити сохраняются как отдельные записи в базе данных или являются частью агрегата.

Примеры названий помогают понять разницу:

- components — это `ModelConfigID`, `AccountName`, `EmailAddress`, `Money`.
- Entities — это `Account`, `Server`, `ChatSession`, `Order`.

Простое правило: если объект может "изменяться" и при этом оставаться "тем же самым" — это entity. Если объект полностью определяется своими значениями — это component.

## Отличие от Агрегатов

Энтити — это объекты с собственной идентичностью и состоянием, которые описывают, как теоретически они могут быть изменены в соответствии с бизнес-логикой. Они не гарантируют синхронизацию с внешним миром, а так же не описывают, как 

Агрегаты же — это транзакционные границы, которые группируют несколько связанных энтити и компонентов, при этом синхронизируя их состояния с внешним миром. Агрегат гарантирует целостность и инварианты для всей группы объектов, управляя их состоянием как единое целое.

## Принципы проектирования

1. **Минимизируйте мутабельность:** каждое изменяемое поле должно иметь причину -> *почему его надо модифицировать?*
2. **Все внешние значения входа сначала приводите к component типам**, затем записывайте в entity (иначе размазывается валидация).
3. **Методы изменения**: всегда возвращают `error`, если инвариант нарушен. Даже в случае если компонент провалидирован ранее.
4. **Zero value не должен быть валидной entity** (конструктор обязателен). Исключение — когда нужна промежуточная десериализация с последующей валидацией.
5. **Не внедряйте никаких внешних эффектов** (модификация других энтити, колбэки, и тем более запросы к сетке / кэш) прямо в entity; только чистая логика и работа с component значениями.
6. **Конструктор** должен принимать только уже валидированные semantic types; сырые строки/UUID — преобразуйте до вызова.
7. **Идентификатор**: предпочтительно `type <Name>ID struct { uuid.UUID }` (или обёрнутый тип), но хранится в компонентах как отдельный тип, а не «голая» строка.

## Конструкторы / фабрики

Рекомендуемый паттерн:

```go
// Account представляет аккаунт пользователя в системе.
type Account struct {
    id        AccountID       // component
    name      AccountName     // component
    createdAt time.Time       // component (или встроенный тип, если политика позволяет)
    status    AccountStatus   // component (enum-like)
}

// NewAccount создаёт новую entity, гарантируя инварианты.
func NewAccount(id AccountID, name AccountName, now time.Time) (*Account, error) {
    // локальные проверки (кроме уже выполненных в components)
    if now.IsZero() { return nil, ErrInvalidTimestamp }
    return &Account{
        id:        id,
        name:      name,
        createdAt: now.UTC(),
        status:    AccountStatusActive,
    }, nil
}
```

*Здесь `AccountID`, `AccountName`, `AccountStatus` — **components**; их валидация уже произошла на уровне их конструкторов.*

## Изменение состояния

```go
func (a *Account) Rename(to AccountName) error {
    if a.status == AccountStatusBlocked {
        return ErrAccountBlocked
    }
    if a.name == to { // idempotent
        return nil
    }
    a.name = to
    return nil
}
```

Правила:

- Возвращайте *доменные* ошибки (и документируйте их).
- Делайте операции идемпотентными там, где это логично.
- Не смешивайте несколько несвязанных изменений в одном методе.

## Инварианты: где и как

| Уровень        | Пример инварианта                         | Где проверяем              |
|----------------|--------------------------------------------|----------------------------|
| Component      | Строка не пустая, UUID валиден             | В конструкторе компонента  |
| Entity         | Нельзя переименовать заблокированный      | В методе `Rename`          |
| Aggregate root | Суммарный лимит по дочерним entity        | В aggregate (будет позже)  |
| Use case       | Последовательность операций (workflow)    | В соответствующем сервисе  |

## Ошибки

Предпочтительно в пакете entity создать перечисление sentinel ошибок или типизированные обёртки:

```go
var (
    ErrAccountBlocked   = errors.New("account: blocked")
    ErrInvalidTimestamp = errors.New("account: invalid timestamp")
)
```

Не экспортируйте внутренние детали: лучше одна ошибка «blocked» чем пять разных «cannot rename while status=blocked» и т.п.

## Сериализация / хранение

- Entity НЕ обязан знать как он сериализуется → делегируйте адаптерам (ports + adapters).
- Допустимо добавить метод для проекции (например `ToDTO()`), но **избегайте** плотной связи с transport / storage форматом.

## Тестирование

Минимальный набор тестов на entity:

1. Конструктор: валидные входы → ok, невалидные → ожидаемые ошибки.
2. Методы изменения: позитивный сценарий + запрещённые сценарии + идемпотентность.
3. Инварианты: попытка сломать — подтверждаем защиту.
4. Table-driven стиль.

Шаблон теста (псевдо):

```go
func TestAccount_Rename(t *testing.T) {
    acc := testAccountActive()
    newName := MustAccountName("New")
    if err := acc.Rename(newName); err != nil { t.Fatal(err) }
    if acc.Name() != newName { t.Errorf("expected renamed") }
}
```

## Анти‑паттерны (избегать)

- «Анаемичные» entity только с геттерами/сеттерами — логика должна жить здесь, иначе вы вернётесь к *transaction script* хаосу.
- Прямая зависимость от внешних клиентов (`http.Client`, gRPC stubs). Только через ports.
- Логирование внутри entity (кроме, возможно, отладочного в dev сборках) — шумит и затрудняет тесты.
- Использование публичных структур с экспортируемыми полями (ломает инварианты). Закрытые поля + методы.

## Чеклист при добавлении новой entity

```text
[ ] Описана идентичность (ID component)
[ ] Все значимые поля — components / примитивы с явным смыслом
[ ] Конструктор проверяет локальные инварианты
[ ] Методы изменения атомарны и идемпотентны где уместно
[ ] Доменные ошибки перечислены
[ ] Нет прямых внешних зависимостей
[ ] Тесты: ctor / изменения / инварианты
```
